// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OBWriteDomesticStandingOrderConsent5DataInitiation OBWriteDomesticStandingOrderConsent5DataInitiation The Initiation payload is sent by the initiating party to the ASPSP. It is used to request movement of funds from the debtor account to a creditor for a domestic standing order.
//
// swagger:model OBWriteDomesticStandingOrderConsent5DataInitiation
type OBWriteDomesticStandingOrderConsent5DataInitiation struct {

	// creditor account
	// Required: true
	CreditorAccount *OBWriteDomesticStandingOrderConsent5DataInitiationCreditorAccount `json:"CreditorAccount"`

	// debtor account
	DebtorAccount *OBWriteDomesticStandingOrderConsent5DataInitiationDebtorAccount `json:"DebtorAccount,omitempty"`

	// final payment amount
	FinalPaymentAmount *OBWriteDomesticStandingOrderConsent5DataInitiationFinalPaymentAmount `json:"FinalPaymentAmount,omitempty"`

	// The date on which the final payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Format: date-time
	// Format: date-time
	FinalPaymentDateTime strfmt.DateTime `json:"FinalPaymentDateTime,omitempty"`

	// first payment amount
	// Required: true
	FirstPaymentAmount *OBWriteDomesticStandingOrderConsent5DataInitiationFirstPaymentAmount `json:"FirstPaymentAmount"`

	// The date on which the first payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Required: true
	// Format: date-time
	FirstPaymentDateTime strfmt.DateTime `json:"FirstPaymentDateTime"`

	// Individual Definitions:
	// EvryDay - Every day
	// EvryWorkgDay - Every working day
	// IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07)
	// WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07)
	// IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31)
	// QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED).
	// ENGLISH = Paid on the 25th March, 24th June, 29th September and 25th December.
	// SCOTTISH = Paid on the 2nd February, 15th May, 1st August and 11th November.
	// RECEIVED = Paid on the 20th March, 19th June, 24th September and 20th December.
	// Individual Patterns:
	// EvryDay (ScheduleCode)
	// EvryWorkgDay (ScheduleCode)
	// IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek)
	// WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek)
	// IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth)
	// QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay
	// The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here:
	// EvryDay
	// EvryWorkgDay
	// IntrvlWkDay:0[1-9]:0[1-7]
	// WkInMnthDay:0[1-5]:0[1-7]
	// IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01])
	// QtrDay:(ENGLISH|SCOTTISH|RECEIVED)
	// Full Regular Expression:
	// ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$
	// Required: true
	// Pattern: ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$
	Frequency string `json:"Frequency"`

	// Number of the payments that will be made in completing this frequency sequence including any executed since the sequence start date.
	// Max Length: 35
	// Min Length: 1
	NumberOfPayments string `json:"NumberOfPayments,omitempty"`

	// recurring payment amount
	RecurringPaymentAmount *OBWriteDomesticStandingOrderConsent5DataInitiationRecurringPaymentAmount `json:"RecurringPaymentAmount,omitempty"`

	// The date on which the first recurring payment for a Standing Order schedule will be made.
	// Usage: This must be populated only if the first recurring date is different to the first payment date.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Format: date-time
	// Format: date-time
	RecurringPaymentDateTime strfmt.DateTime `json:"RecurringPaymentDateTime,omitempty"`

	// Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
	// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
	// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.
	// Max Length: 35
	// Min Length: 1
	Reference string `json:"Reference,omitempty"`

	// supplementary data
	SupplementaryData OBSupplementaryData1 `json:"SupplementaryData,omitempty"`
}

// Validate validates this o b write domestic standing order consent5 data initiation
func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreditorAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebtorAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinalPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinalPaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstPaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumberOfPayments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurringPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurringPaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateCreditorAccount(formats strfmt.Registry) error {

	if err := validate.Required("CreditorAccount", "body", m.CreditorAccount); err != nil {
		return err
	}

	if m.CreditorAccount != nil {
		if err := m.CreditorAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CreditorAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("CreditorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateDebtorAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.DebtorAccount) { // not required
		return nil
	}

	if m.DebtorAccount != nil {
		if err := m.DebtorAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("DebtorAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("DebtorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateFinalPaymentAmount(formats strfmt.Registry) error {
	if swag.IsZero(m.FinalPaymentAmount) { // not required
		return nil
	}

	if m.FinalPaymentAmount != nil {
		if err := m.FinalPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("FinalPaymentAmount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("FinalPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateFinalPaymentDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.FinalPaymentDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("FinalPaymentDateTime", "body", "date-time", m.FinalPaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateFirstPaymentAmount(formats strfmt.Registry) error {

	if err := validate.Required("FirstPaymentAmount", "body", m.FirstPaymentAmount); err != nil {
		return err
	}

	if m.FirstPaymentAmount != nil {
		if err := m.FirstPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("FirstPaymentAmount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("FirstPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateFirstPaymentDateTime(formats strfmt.Registry) error {

	if err := validate.Required("FirstPaymentDateTime", "body", strfmt.DateTime(m.FirstPaymentDateTime)); err != nil {
		return err
	}

	if err := validate.FormatOf("FirstPaymentDateTime", "body", "date-time", m.FirstPaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateFrequency(formats strfmt.Registry) error {

	if err := validate.RequiredString("Frequency", "body", m.Frequency); err != nil {
		return err
	}

	if err := validate.Pattern("Frequency", "body", m.Frequency, `^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$`); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateNumberOfPayments(formats strfmt.Registry) error {
	if swag.IsZero(m.NumberOfPayments) { // not required
		return nil
	}

	if err := validate.MinLength("NumberOfPayments", "body", m.NumberOfPayments, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("NumberOfPayments", "body", m.NumberOfPayments, 35); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateRecurringPaymentAmount(formats strfmt.Registry) error {
	if swag.IsZero(m.RecurringPaymentAmount) { // not required
		return nil
	}

	if m.RecurringPaymentAmount != nil {
		if err := m.RecurringPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("RecurringPaymentAmount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("RecurringPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateRecurringPaymentDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.RecurringPaymentDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("RecurringPaymentDateTime", "body", "date-time", m.RecurringPaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) validateReference(formats strfmt.Registry) error {
	if swag.IsZero(m.Reference) { // not required
		return nil
	}

	if err := validate.MinLength("Reference", "body", m.Reference, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Reference", "body", m.Reference, 35); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order consent5 data initiation based on the context it is used
func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreditorAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDebtorAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFinalPaymentAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirstPaymentAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecurringPaymentAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) contextValidateCreditorAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.CreditorAccount != nil {
		if err := m.CreditorAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CreditorAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("CreditorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) contextValidateDebtorAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.DebtorAccount != nil {
		if err := m.DebtorAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("DebtorAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("DebtorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) contextValidateFinalPaymentAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.FinalPaymentAmount != nil {
		if err := m.FinalPaymentAmount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("FinalPaymentAmount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("FinalPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) contextValidateFirstPaymentAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.FirstPaymentAmount != nil {
		if err := m.FirstPaymentAmount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("FirstPaymentAmount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("FirstPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) contextValidateRecurringPaymentAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.RecurringPaymentAmount != nil {
		if err := m.RecurringPaymentAmount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("RecurringPaymentAmount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("RecurringPaymentAmount")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderConsent5DataInitiation) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderConsent5DataInitiation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
