// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ServerDump server dump
//
// swagger:model ServerDump
type ServerDump struct {

	// Access token strategy
	//
	// You can choose to go either with `JWT` or `opaque` tokens.
	//
	// The content of JSON Web Tokens is readable and it is possible to be decoded by anyone that
	// has a secret or a public key in their possession.
	//
	// Opaque tokens are in a proprietary form that contains an identifier to information stored on
	// the athorization server. To validate an opaque token, the recipient must call the server that
	// issued the token.
	// Example: jwt
	// Enum: [jwt opaque]
	AccessTokenStrategy string `json:"access_token_strategy,omitempty"`

	// Access token time to live
	//
	// After an access token reaches its time to live, it expires and it cannot be used to
	// authenticate the client application.
	// Example: 1h10m30s
	// Format: duration
	AccessTokenTTL strfmt.Duration `json:"access_token_ttl,omitempty"`

	// advanced
	Advanced *AdvancedConfiguration `json:"advanced,omitempty"`

	// authentication context settings
	AuthenticationContextSettings *AuthenticationContextSettings `json:"authentication_context_settings,omitempty"`

	// Authorization code time to live
	//
	// After an authorization code reaches its time to live, it expires and it cannot be used to
	// authorize the request to the `/token` endpoint.
	// Example: 10m0s
	// Format: duration
	AuthorizationCodeTTL strfmt.Duration `json:"authorization_code_ttl,omitempty"`

	// backchannel token delivery modes supported
	BackchannelTokenDeliveryModesSupported []string `json:"backchannel_token_delivery_modes_supported"`

	// backchannel user code parameter supported
	BackchannelUserCodeParameterSupported bool `json:"backchannel_user_code_parameter_supported,omitempty"`

	// cdr
	Cdr *CDRConfiguration `json:"cdr,omitempty"`

	// Your server's label color in a HEX format.
	// Example: #007FFF
	Color string `json:"color,omitempty"`

	// Namespace used when creating Open Banking Brasil consent IDs
	//
	// Consent IDs will have the form of urn:<consent_id_namespace>:<uid> when this is set.
	// If this is empty, the tenant id is used by default
	ConsentIDNamespace string `json:"consent_id_namespace,omitempty"`

	// Cookie max age
	//
	// Defines how long a cookie can live until it expires.
	// Example: 1h10m30s
	// Format: duration
	CookieMaxAge strfmt.Duration `json:"cookie_max_age,omitempty"`

	// Defines a custom issuer URL that can be used as the value of the `iss` claim in an access
	// token.
	//
	// If not provided, it is built dynamically based on the server's URL.
	// Example: http://example.com/default/default
	CustomIssuerURL string `json:"custom_issuer_url,omitempty"`

	// Display description of the workspace
	// Example: Server description
	Description string `json:"description,omitempty"`

	// device authorization
	DeviceAuthorization *DeviceAuthorizationConfiguration `json:"device_authorization,omitempty"`

	// flag to skip default claims creation (applicable only if server does not exist)
	DoNotCreateDefaultClaims bool `json:"do_not_create_default_claims,omitempty"`

	// dynamic client registration
	DynamicClientRegistration *DynamicClientRegistrationSettings `json:"dynamic_client_registration,omitempty"`

	// You can use this property to define a separator that is used for dynamic scopes.
	//
	// For example, the default separator is `.`, so the scope could look like the following:
	// `users.*`.
	//
	// For Open Banking Brazil compliant servers, the `:` separator should be used.
	DynamicScopeSeparator string `json:"dynamic_scope_separator,omitempty"`

	// Deprecated: Use IDPDiscovery instead
	//
	// If enabled, IDP discovery automatically redirects the user to their own IDP and does not
	// display IDPs of other users while the users accesses the server/application.
	// Example: false
	EnableIdpDiscovery bool `json:"enable_idp_discovery,omitempty"`

	// Deprecated
	//
	// If enabled, it is possible to manually register clients withouth the use of software
	// statements.
	//
	// This flag is enabled, when the `enable_trust_anchor` flag is set to `false`. You can disable
	// it using API, but it cannot be manually enabled.
	EnableLegacyClientsWithNoSoftwareStatement bool `json:"enable_legacy_clients_with_no_software_statement,omitempty"`

	// If enabled, the server is visible on the Quick Access tab on the login page.
	EnableQuickAccess bool `json:"enable_quick_access,omitempty"`

	// If enabled, it makes it obligatory to provide a software statement signed by a trusted certificate authority
	//
	// when registering a client application with the use of the Dynamic Client Registration (DCR).
	//
	// In public key infrastructure (PKI), trust anchors are certification authorities. They are
	// represented by a certificate that is used to verify the signature of a certificate issued by
	// a particular trust anchor.
	EnableTrustAnchor bool `json:"enable_trust_anchor,omitempty"`

	// When enabled, the authorization server will enforce encrypted id tokens it issues
	EnforceIDTokenEncryption bool `json:"enforce_id_token_encryption,omitempty"`

	// Define whether you want to enforce using the Proof Key of Code Exchange (PKCE) for both
	// private and public clients.
	//
	// PKCE is an OAuth security extension that prevents malicious applications or codes that
	// intercepted authorization code from exchanging it for an access token.
	// Example: false
	EnforcePkce bool `json:"enforce_pkce,omitempty"`

	// Define whether you want to enforce using the Proof Key of Code Exchange (PKCE) for
	// public clients.
	//
	// Public clients, like mobile applications or JavaScript-based applications, by their design,
	// cannot store client secrets securely. For such clients, even encrypting the client secret
	// inside the applicationâ€™s code is not a reliable way of protecting secrets as the application
	// can be decompiled and the client secret can be extracted while it is decrypted in the memory
	// of the application.
	//
	// For those reasons, ACP supports the use of PKCE as an addition to the authorization code
	// grant flow to provide a secure alternative to the implicit grant flow.
	// Example: false
	EnforcePkceForPublicClients bool `json:"enforce_pkce_for_public_clients,omitempty"`

	// fdx
	Fdx *FDXConfiguration `json:"fdx,omitempty"`

	// An array that defines which of the OAuth 2.0 grant types are enabled for the authorization server.
	// Example: ["authorization_code","implicit","refresh_token","client_credentials"]
	GrantTypes []string `json:"grant_types"`

	// Unique identifier of an authorization server (workspace)
	//
	// If not provided, a random ID is generated.
	// Example: default
	ID string `json:"id,omitempty"`

	// ID token time to live
	//
	// After an ID token reaches its time to live, it expires and it cannot be used to provide
	// user profile information to a client application.
	// Example: 1h10m30s
	// Format: duration
	IDTokenTTL strfmt.Duration `json:"id_token_ttl,omitempty"`

	// identity assurance
	IdentityAssurance *IdentityAssuranceConfiguration `json:"identity_assurance,omitempty"`

	// idp discovery
	IdpDiscovery *IDPDiscovery `json:"idp_discovery,omitempty"`

	// flag to initialize server default configuration (applicable only if server does not exist)
	Initialize bool `json:"initialize,omitempty"`

	// Issuer ID that will be used to set `iss` claim on signed messages
	//
	// If issuer_id is not set then default issuer_url will be used
	// Example: 5647fe90-f6bc-11eb-9a03-0242ac130003
	IssuerID string `json:"issuer_id,omitempty"`

	// jwks
	Jwks *ServerJWKs `json:"jwks,omitempty"`

	// Determines which type of asymmetric algorithms (RSA or ECDSA) is used to generate keys for signing access and
	// ID tokens.
	//
	// It is used only as an input parameter for the Create Authorization Server API.
	// Example: rsa
	// Enum: [rsa ecdsa ps]
	KeyType string `json:"key_type,omitempty"`

	// legal entity
	LegalEntity *LegalEntity `json:"legal_entity,omitempty"`

	// Logo URI
	LogoURI string `json:"logo_uri,omitempty"`

	// metadata
	Metadata *ServerMetadata `json:"metadata,omitempty"`

	// Display name of the workspace
	//
	// If not provided, a random ID is generated.
	// Example: default
	Name string `json:"name,omitempty"`

	// obbr
	Obbr *OBBRConfiguration `json:"obbr,omitempty"`

	// organization
	Organization *OrganizationConfiguration `json:"organization,omitempty"`

	// Optional ID of a parent server
	ParentID string `json:"parent_id,omitempty"`

	// The profile of a server
	//
	// ACP is delivered with preconfigured workspace templates that enable quick and easy setup for
	// specific configuration patterns. For example, you can instantly create an Open Banking
	// compliant workspace that has all of the required mechanisms and settings already in place.
	// Example: default
	// Enum: [default demo workforce consumer partners third_party fapi_advanced fapi_rw fapi_ro openbanking_uk_fapi_advanced openbanking_uk openbanking_br cdr_australia cdr_australia_fapi_rw fdx openbanking_ksa fapi_20_security fapi_20_message_signing connect_id]
	Profile string `json:"profile,omitempty"`

	// Custom pushed authentication request TTL
	// If not provided, TTL is set to 60 seconds.
	// Format: duration
	PushedAuthorizationRequestTTL strfmt.Duration `json:"pushed_authorization_request_ttl,omitempty"`

	// Refresh token time to live
	//
	// After a refresh token reaches its time to live, it expires and it cannot be used to obtain
	// new access tokens for a client application.
	// Example: 720h0m0s
	// Format: duration
	RefreshTokenTTL strfmt.Duration `json:"refresh_token_ttl,omitempty"`

	// Boolean parameter indicating whether the authorization server accepts authorization request data only via PAR.
	RequirePushedAuthorizationRequests bool `json:"require_pushed_authorization_requests,omitempty"`

	// response types
	ResponseTypes ResponseTypes `json:"response_types,omitempty"`

	// You can provide root Certificate Authority (CA) certificates encoded to the Privacy-Enhanced
	// Mail (PEM) file format which are used for the `tls_client_auth` and the
	// `self_signed_tls_client_auth` client authentication methods that use the Mutual
	// Transport Layer Security (mTLS).
	//
	// If not set, the system root CA certifiates are used instead.
	RootCas string `json:"root_cas,omitempty"`

	// An array of rotated secrets that are still used to validate tokens
	// Example: ["jFpwIvuKJP46J71WqszPv1SrzoUr-cSILP9EPdlClB4"]
	RotatedSecrets []string `json:"rotated_secrets"`

	// saml
	Saml *SAMLConfiguration `json:"saml,omitempty"`

	// Secret used for hashing
	//
	// It must have at least 32 characters. If not provided, it is generated.
	// Example: hW5WhKX_7w7BLwUQ6mn7Cp70_OoKI_F1y1hLS5U8lIU
	Secret string `json:"secret,omitempty"`

	// sso
	Sso *SSOConfiguration `json:"sso,omitempty"`

	// styling
	Styling *Styling `json:"styling,omitempty"`

	// Define the format of a subject
	// When set to hash sub value is a one way hash of idp id and idp sub
	// Enum: [hash legacy]
	SubjectFormat string `json:"subject_format,omitempty"`

	// Salt used to hash `subject` when the `pairwise` subject type is used.
	//
	// Salt is a random data which is used as an additional input to one-way functions that hashes
	// data, passwords, and, in this case, subjects.
	//
	// It is recommended that your salt value is long for security reasons. Preferably, the salt
	// value should be at least the same length as the output of the hash.
	//
	// If not provided, it is generated.
	SubjectIdentifierAlgorithmSalt string `json:"subject_identifier_algorithm_salt,omitempty"`

	// An array that defines supported subject identifier types.
	//
	// Subject identifiers identify an end-user. They are locally unique and never reassigned within the Issuer,
	// and are intended to be consumed by client applications. There are two types
	// of subject identifiers: `public` and `pairwise`.
	//
	// `public` identifiers provide the same `sub` claim value to all client applications.
	// `pairwise` identifiers provide different `sub` claim values to each client application. With
	// this approach, it makes it impossible for client applications to correlate the end-user's
	// activity without their permission.
	// Example: ["public","pairwise"]
	SubjectIdentifierTypes []string `json:"subject_identifier_types"`

	// If true this workspace can be used as a template when creating a new ones.
	Template bool `json:"template,omitempty"`

	// ID of a tenant
	// Example: default
	// Required: true
	TenantID string `json:"tenant_id"`

	// An array that lists all of the supported token endpoint authentication methods for the
	// authorization server.
	TokenEndpointAuthMethods []string `json:"token_endpoint_auth_methods"`

	// Token endpoint auth signing supported alg values
	//
	// Supported algorithms: HS256, RS256, ES256, PS256
	//
	// At least one algorithm must be set.
	//
	// The default values depends on the server security profile.
	TokenEndpointAuthSigningAlgValues []string `json:"token_endpoint_auth_signing_alg_values"`

	// Deprecated: Use TokenEndpointAuthMethods instead
	TokenEndpointAuthnMethods []string `json:"token_endpoint_authn_methods"`

	// trust anchor configuration
	TrustAnchorConfiguration *TrustAnchorConfiguration `json:"trust_anchor_configuration,omitempty"`

	// Server type
	//
	// It is an internal property used to recognize if the server is created for an admin portal,
	// a developer portal, or if it is a system or a regular workspace.
	// Example: regular
	// Enum: [admin developer system regular organization]
	Type string `json:"type,omitempty"`

	// server version to track internal changes
	// version that is currently the latest: 3
	Version int64 `json:"version,omitempty"`
}

// Validate validates this server dump
func (m *ServerDump) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessTokenStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessTokenTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdvanced(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthenticationContextSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthorizationCodeTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCdr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCookieMaxAge(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeviceAuthorization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicClientRegistration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFdx(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGrantTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIDTokenTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentityAssurance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdpDiscovery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJwks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLegalEntity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProfile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePushedAuthorizationRequestTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefreshTokenTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSaml(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSso(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStyling(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubjectFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubjectIdentifierTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenantID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTokenEndpointAuthMethods(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTokenEndpointAuthnMethods(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTrustAnchorConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var serverDumpTypeAccessTokenStrategyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["jwt","opaque"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDumpTypeAccessTokenStrategyPropEnum = append(serverDumpTypeAccessTokenStrategyPropEnum, v)
	}
}

const (

	// ServerDumpAccessTokenStrategyJwt captures enum value "jwt"
	ServerDumpAccessTokenStrategyJwt string = "jwt"

	// ServerDumpAccessTokenStrategyOpaque captures enum value "opaque"
	ServerDumpAccessTokenStrategyOpaque string = "opaque"
)

// prop value enum
func (m *ServerDump) validateAccessTokenStrategyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDumpTypeAccessTokenStrategyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDump) validateAccessTokenStrategy(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessTokenStrategy) { // not required
		return nil
	}

	// value enum
	if err := m.validateAccessTokenStrategyEnum("access_token_strategy", "body", m.AccessTokenStrategy); err != nil {
		return err
	}

	return nil
}

func (m *ServerDump) validateAccessTokenTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessTokenTTL) { // not required
		return nil
	}

	if err := validate.FormatOf("access_token_ttl", "body", "duration", m.AccessTokenTTL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ServerDump) validateAdvanced(formats strfmt.Registry) error {
	if swag.IsZero(m.Advanced) { // not required
		return nil
	}

	if m.Advanced != nil {
		if err := m.Advanced.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("advanced")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("advanced")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateAuthenticationContextSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthenticationContextSettings) { // not required
		return nil
	}

	if m.AuthenticationContextSettings != nil {
		if err := m.AuthenticationContextSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authentication_context_settings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authentication_context_settings")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateAuthorizationCodeTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthorizationCodeTTL) { // not required
		return nil
	}

	if err := validate.FormatOf("authorization_code_ttl", "body", "duration", m.AuthorizationCodeTTL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ServerDump) validateCdr(formats strfmt.Registry) error {
	if swag.IsZero(m.Cdr) { // not required
		return nil
	}

	if m.Cdr != nil {
		if err := m.Cdr.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cdr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cdr")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateCookieMaxAge(formats strfmt.Registry) error {
	if swag.IsZero(m.CookieMaxAge) { // not required
		return nil
	}

	if err := validate.FormatOf("cookie_max_age", "body", "duration", m.CookieMaxAge.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ServerDump) validateDeviceAuthorization(formats strfmt.Registry) error {
	if swag.IsZero(m.DeviceAuthorization) { // not required
		return nil
	}

	if m.DeviceAuthorization != nil {
		if err := m.DeviceAuthorization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("device_authorization")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("device_authorization")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateDynamicClientRegistration(formats strfmt.Registry) error {
	if swag.IsZero(m.DynamicClientRegistration) { // not required
		return nil
	}

	if m.DynamicClientRegistration != nil {
		if err := m.DynamicClientRegistration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dynamic_client_registration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dynamic_client_registration")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateFdx(formats strfmt.Registry) error {
	if swag.IsZero(m.Fdx) { // not required
		return nil
	}

	if m.Fdx != nil {
		if err := m.Fdx.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fdx")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fdx")
			}
			return err
		}
	}

	return nil
}

var serverDumpGrantTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["authorization_code","implicit","client_credentials","refresh_token","password","urn:ietf:params:oauth:grant-type:jwt-bearer","urn:openid:params:grant-type:ciba","urn:ietf:params:oauth:grant-type:token-exchange","urn:ietf:params:oauth:grant-type:device_code"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDumpGrantTypesItemsEnum = append(serverDumpGrantTypesItemsEnum, v)
	}
}

func (m *ServerDump) validateGrantTypesItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDumpGrantTypesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDump) validateGrantTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.GrantTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.GrantTypes); i++ {

		// value enum
		if err := m.validateGrantTypesItemsEnum("grant_types"+"."+strconv.Itoa(i), "body", m.GrantTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *ServerDump) validateIDTokenTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.IDTokenTTL) { // not required
		return nil
	}

	if err := validate.FormatOf("id_token_ttl", "body", "duration", m.IDTokenTTL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ServerDump) validateIdentityAssurance(formats strfmt.Registry) error {
	if swag.IsZero(m.IdentityAssurance) { // not required
		return nil
	}

	if m.IdentityAssurance != nil {
		if err := m.IdentityAssurance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("identity_assurance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("identity_assurance")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateIdpDiscovery(formats strfmt.Registry) error {
	if swag.IsZero(m.IdpDiscovery) { // not required
		return nil
	}

	if m.IdpDiscovery != nil {
		if err := m.IdpDiscovery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("idp_discovery")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("idp_discovery")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateJwks(formats strfmt.Registry) error {
	if swag.IsZero(m.Jwks) { // not required
		return nil
	}

	if m.Jwks != nil {
		if err := m.Jwks.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jwks")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jwks")
			}
			return err
		}
	}

	return nil
}

var serverDumpTypeKeyTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["rsa","ecdsa","ps"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDumpTypeKeyTypePropEnum = append(serverDumpTypeKeyTypePropEnum, v)
	}
}

const (

	// ServerDumpKeyTypeRsa captures enum value "rsa"
	ServerDumpKeyTypeRsa string = "rsa"

	// ServerDumpKeyTypeEcdsa captures enum value "ecdsa"
	ServerDumpKeyTypeEcdsa string = "ecdsa"

	// ServerDumpKeyTypePs captures enum value "ps"
	ServerDumpKeyTypePs string = "ps"
)

// prop value enum
func (m *ServerDump) validateKeyTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDumpTypeKeyTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDump) validateKeyType(formats strfmt.Registry) error {
	if swag.IsZero(m.KeyType) { // not required
		return nil
	}

	// value enum
	if err := m.validateKeyTypeEnum("key_type", "body", m.KeyType); err != nil {
		return err
	}

	return nil
}

func (m *ServerDump) validateLegalEntity(formats strfmt.Registry) error {
	if swag.IsZero(m.LegalEntity) { // not required
		return nil
	}

	if m.LegalEntity != nil {
		if err := m.LegalEntity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("legal_entity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("legal_entity")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateObbr(formats strfmt.Registry) error {
	if swag.IsZero(m.Obbr) { // not required
		return nil
	}

	if m.Obbr != nil {
		if err := m.Obbr.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("obbr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("obbr")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateOrganization(formats strfmt.Registry) error {
	if swag.IsZero(m.Organization) { // not required
		return nil
	}

	if m.Organization != nil {
		if err := m.Organization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("organization")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("organization")
			}
			return err
		}
	}

	return nil
}

var serverDumpTypeProfilePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","demo","workforce","consumer","partners","third_party","fapi_advanced","fapi_rw","fapi_ro","openbanking_uk_fapi_advanced","openbanking_uk","openbanking_br","cdr_australia","cdr_australia_fapi_rw","fdx","openbanking_ksa","fapi_20_security","fapi_20_message_signing","connect_id"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDumpTypeProfilePropEnum = append(serverDumpTypeProfilePropEnum, v)
	}
}

const (

	// ServerDumpProfileDefault captures enum value "default"
	ServerDumpProfileDefault string = "default"

	// ServerDumpProfileDemo captures enum value "demo"
	ServerDumpProfileDemo string = "demo"

	// ServerDumpProfileWorkforce captures enum value "workforce"
	ServerDumpProfileWorkforce string = "workforce"

	// ServerDumpProfileConsumer captures enum value "consumer"
	ServerDumpProfileConsumer string = "consumer"

	// ServerDumpProfilePartners captures enum value "partners"
	ServerDumpProfilePartners string = "partners"

	// ServerDumpProfileThirdParty captures enum value "third_party"
	ServerDumpProfileThirdParty string = "third_party"

	// ServerDumpProfileFapiAdvanced captures enum value "fapi_advanced"
	ServerDumpProfileFapiAdvanced string = "fapi_advanced"

	// ServerDumpProfileFapiRw captures enum value "fapi_rw"
	ServerDumpProfileFapiRw string = "fapi_rw"

	// ServerDumpProfileFapiRo captures enum value "fapi_ro"
	ServerDumpProfileFapiRo string = "fapi_ro"

	// ServerDumpProfileOpenbankingUkFapiAdvanced captures enum value "openbanking_uk_fapi_advanced"
	ServerDumpProfileOpenbankingUkFapiAdvanced string = "openbanking_uk_fapi_advanced"

	// ServerDumpProfileOpenbankingUk captures enum value "openbanking_uk"
	ServerDumpProfileOpenbankingUk string = "openbanking_uk"

	// ServerDumpProfileOpenbankingBr captures enum value "openbanking_br"
	ServerDumpProfileOpenbankingBr string = "openbanking_br"

	// ServerDumpProfileCdrAustralia captures enum value "cdr_australia"
	ServerDumpProfileCdrAustralia string = "cdr_australia"

	// ServerDumpProfileCdrAustraliaFapiRw captures enum value "cdr_australia_fapi_rw"
	ServerDumpProfileCdrAustraliaFapiRw string = "cdr_australia_fapi_rw"

	// ServerDumpProfileFdx captures enum value "fdx"
	ServerDumpProfileFdx string = "fdx"

	// ServerDumpProfileOpenbankingKsa captures enum value "openbanking_ksa"
	ServerDumpProfileOpenbankingKsa string = "openbanking_ksa"

	// ServerDumpProfileFapi20Security captures enum value "fapi_20_security"
	ServerDumpProfileFapi20Security string = "fapi_20_security"

	// ServerDumpProfileFapi20MessageSigning captures enum value "fapi_20_message_signing"
	ServerDumpProfileFapi20MessageSigning string = "fapi_20_message_signing"

	// ServerDumpProfileConnectID captures enum value "connect_id"
	ServerDumpProfileConnectID string = "connect_id"
)

// prop value enum
func (m *ServerDump) validateProfileEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDumpTypeProfilePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDump) validateProfile(formats strfmt.Registry) error {
	if swag.IsZero(m.Profile) { // not required
		return nil
	}

	// value enum
	if err := m.validateProfileEnum("profile", "body", m.Profile); err != nil {
		return err
	}

	return nil
}

func (m *ServerDump) validatePushedAuthorizationRequestTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.PushedAuthorizationRequestTTL) { // not required
		return nil
	}

	if err := validate.FormatOf("pushed_authorization_request_ttl", "body", "duration", m.PushedAuthorizationRequestTTL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ServerDump) validateRefreshTokenTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.RefreshTokenTTL) { // not required
		return nil
	}

	if err := validate.FormatOf("refresh_token_ttl", "body", "duration", m.RefreshTokenTTL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ServerDump) validateResponseTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.ResponseTypes) { // not required
		return nil
	}

	if err := m.ResponseTypes.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("response_types")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("response_types")
		}
		return err
	}

	return nil
}

func (m *ServerDump) validateSaml(formats strfmt.Registry) error {
	if swag.IsZero(m.Saml) { // not required
		return nil
	}

	if m.Saml != nil {
		if err := m.Saml.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("saml")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("saml")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateSso(formats strfmt.Registry) error {
	if swag.IsZero(m.Sso) { // not required
		return nil
	}

	if m.Sso != nil {
		if err := m.Sso.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sso")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sso")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) validateStyling(formats strfmt.Registry) error {
	if swag.IsZero(m.Styling) { // not required
		return nil
	}

	if m.Styling != nil {
		if err := m.Styling.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("styling")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("styling")
			}
			return err
		}
	}

	return nil
}

var serverDumpTypeSubjectFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["hash","legacy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDumpTypeSubjectFormatPropEnum = append(serverDumpTypeSubjectFormatPropEnum, v)
	}
}

const (

	// ServerDumpSubjectFormatHash captures enum value "hash"
	ServerDumpSubjectFormatHash string = "hash"

	// ServerDumpSubjectFormatLegacy captures enum value "legacy"
	ServerDumpSubjectFormatLegacy string = "legacy"
)

// prop value enum
func (m *ServerDump) validateSubjectFormatEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDumpTypeSubjectFormatPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDump) validateSubjectFormat(formats strfmt.Registry) error {
	if swag.IsZero(m.SubjectFormat) { // not required
		return nil
	}

	// value enum
	if err := m.validateSubjectFormatEnum("subject_format", "body", m.SubjectFormat); err != nil {
		return err
	}

	return nil
}

var serverDumpSubjectIdentifierTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["public","pairwise"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDumpSubjectIdentifierTypesItemsEnum = append(serverDumpSubjectIdentifierTypesItemsEnum, v)
	}
}

func (m *ServerDump) validateSubjectIdentifierTypesItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDumpSubjectIdentifierTypesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDump) validateSubjectIdentifierTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.SubjectIdentifierTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.SubjectIdentifierTypes); i++ {

		// value enum
		if err := m.validateSubjectIdentifierTypesItemsEnum("subject_identifier_types"+"."+strconv.Itoa(i), "body", m.SubjectIdentifierTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *ServerDump) validateTenantID(formats strfmt.Registry) error {

	if err := validate.RequiredString("tenant_id", "body", m.TenantID); err != nil {
		return err
	}

	return nil
}

var serverDumpTokenEndpointAuthMethodsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["client_secret_basic","client_secret_post","client_secret_jwt","private_key_jwt","self_signed_tls_client_auth","tls_client_auth","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDumpTokenEndpointAuthMethodsItemsEnum = append(serverDumpTokenEndpointAuthMethodsItemsEnum, v)
	}
}

func (m *ServerDump) validateTokenEndpointAuthMethodsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDumpTokenEndpointAuthMethodsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDump) validateTokenEndpointAuthMethods(formats strfmt.Registry) error {
	if swag.IsZero(m.TokenEndpointAuthMethods) { // not required
		return nil
	}

	for i := 0; i < len(m.TokenEndpointAuthMethods); i++ {

		// value enum
		if err := m.validateTokenEndpointAuthMethodsItemsEnum("token_endpoint_auth_methods"+"."+strconv.Itoa(i), "body", m.TokenEndpointAuthMethods[i]); err != nil {
			return err
		}

	}

	return nil
}

var serverDumpTokenEndpointAuthnMethodsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["client_secret_basic","client_secret_post","client_secret_jwt","private_key_jwt","self_signed_tls_client_auth","tls_client_auth","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDumpTokenEndpointAuthnMethodsItemsEnum = append(serverDumpTokenEndpointAuthnMethodsItemsEnum, v)
	}
}

func (m *ServerDump) validateTokenEndpointAuthnMethodsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDumpTokenEndpointAuthnMethodsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDump) validateTokenEndpointAuthnMethods(formats strfmt.Registry) error {
	if swag.IsZero(m.TokenEndpointAuthnMethods) { // not required
		return nil
	}

	for i := 0; i < len(m.TokenEndpointAuthnMethods); i++ {

		// value enum
		if err := m.validateTokenEndpointAuthnMethodsItemsEnum("token_endpoint_authn_methods"+"."+strconv.Itoa(i), "body", m.TokenEndpointAuthnMethods[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *ServerDump) validateTrustAnchorConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.TrustAnchorConfiguration) { // not required
		return nil
	}

	if m.TrustAnchorConfiguration != nil {
		if err := m.TrustAnchorConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("trust_anchor_configuration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("trust_anchor_configuration")
			}
			return err
		}
	}

	return nil
}

var serverDumpTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["admin","developer","system","regular","organization"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDumpTypeTypePropEnum = append(serverDumpTypeTypePropEnum, v)
	}
}

const (

	// ServerDumpTypeAdmin captures enum value "admin"
	ServerDumpTypeAdmin string = "admin"

	// ServerDumpTypeDeveloper captures enum value "developer"
	ServerDumpTypeDeveloper string = "developer"

	// ServerDumpTypeSystem captures enum value "system"
	ServerDumpTypeSystem string = "system"

	// ServerDumpTypeRegular captures enum value "regular"
	ServerDumpTypeRegular string = "regular"

	// ServerDumpTypeOrganization captures enum value "organization"
	ServerDumpTypeOrganization string = "organization"
)

// prop value enum
func (m *ServerDump) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDumpTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDump) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this server dump based on the context it is used
func (m *ServerDump) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdvanced(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthenticationContextSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCdr(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeviceAuthorization(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDynamicClientRegistration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFdx(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIdentityAssurance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIdpDiscovery(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJwks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLegalEntity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObbr(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrganization(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResponseTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSaml(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSso(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStyling(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTrustAnchorConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServerDump) contextValidateAdvanced(ctx context.Context, formats strfmt.Registry) error {

	if m.Advanced != nil {

		if swag.IsZero(m.Advanced) { // not required
			return nil
		}

		if err := m.Advanced.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("advanced")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("advanced")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateAuthenticationContextSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthenticationContextSettings != nil {

		if swag.IsZero(m.AuthenticationContextSettings) { // not required
			return nil
		}

		if err := m.AuthenticationContextSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authentication_context_settings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authentication_context_settings")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateCdr(ctx context.Context, formats strfmt.Registry) error {

	if m.Cdr != nil {

		if swag.IsZero(m.Cdr) { // not required
			return nil
		}

		if err := m.Cdr.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cdr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cdr")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateDeviceAuthorization(ctx context.Context, formats strfmt.Registry) error {

	if m.DeviceAuthorization != nil {

		if swag.IsZero(m.DeviceAuthorization) { // not required
			return nil
		}

		if err := m.DeviceAuthorization.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("device_authorization")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("device_authorization")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateDynamicClientRegistration(ctx context.Context, formats strfmt.Registry) error {

	if m.DynamicClientRegistration != nil {

		if swag.IsZero(m.DynamicClientRegistration) { // not required
			return nil
		}

		if err := m.DynamicClientRegistration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dynamic_client_registration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dynamic_client_registration")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateFdx(ctx context.Context, formats strfmt.Registry) error {

	if m.Fdx != nil {

		if swag.IsZero(m.Fdx) { // not required
			return nil
		}

		if err := m.Fdx.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fdx")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fdx")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateIdentityAssurance(ctx context.Context, formats strfmt.Registry) error {

	if m.IdentityAssurance != nil {

		if swag.IsZero(m.IdentityAssurance) { // not required
			return nil
		}

		if err := m.IdentityAssurance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("identity_assurance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("identity_assurance")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateIdpDiscovery(ctx context.Context, formats strfmt.Registry) error {

	if m.IdpDiscovery != nil {

		if swag.IsZero(m.IdpDiscovery) { // not required
			return nil
		}

		if err := m.IdpDiscovery.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("idp_discovery")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("idp_discovery")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateJwks(ctx context.Context, formats strfmt.Registry) error {

	if m.Jwks != nil {

		if swag.IsZero(m.Jwks) { // not required
			return nil
		}

		if err := m.Jwks.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jwks")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jwks")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateLegalEntity(ctx context.Context, formats strfmt.Registry) error {

	if m.LegalEntity != nil {

		if swag.IsZero(m.LegalEntity) { // not required
			return nil
		}

		if err := m.LegalEntity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("legal_entity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("legal_entity")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata != nil {

		if swag.IsZero(m.Metadata) { // not required
			return nil
		}

		if err := m.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateObbr(ctx context.Context, formats strfmt.Registry) error {

	if m.Obbr != nil {

		if swag.IsZero(m.Obbr) { // not required
			return nil
		}

		if err := m.Obbr.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("obbr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("obbr")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateOrganization(ctx context.Context, formats strfmt.Registry) error {

	if m.Organization != nil {

		if swag.IsZero(m.Organization) { // not required
			return nil
		}

		if err := m.Organization.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("organization")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("organization")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateResponseTypes(ctx context.Context, formats strfmt.Registry) error {

	if err := m.ResponseTypes.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("response_types")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("response_types")
		}
		return err
	}

	return nil
}

func (m *ServerDump) contextValidateSaml(ctx context.Context, formats strfmt.Registry) error {

	if m.Saml != nil {

		if swag.IsZero(m.Saml) { // not required
			return nil
		}

		if err := m.Saml.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("saml")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("saml")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateSso(ctx context.Context, formats strfmt.Registry) error {

	if m.Sso != nil {

		if swag.IsZero(m.Sso) { // not required
			return nil
		}

		if err := m.Sso.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sso")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sso")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateStyling(ctx context.Context, formats strfmt.Registry) error {

	if m.Styling != nil {

		if swag.IsZero(m.Styling) { // not required
			return nil
		}

		if err := m.Styling.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("styling")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("styling")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDump) contextValidateTrustAnchorConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.TrustAnchorConfiguration != nil {

		if swag.IsZero(m.TrustAnchorConfiguration) { // not required
			return nil
		}

		if err := m.TrustAnchorConfiguration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("trust_anchor_configuration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("trust_anchor_configuration")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ServerDump) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServerDump) UnmarshalBinary(b []byte) error {
	var res ServerDump
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
