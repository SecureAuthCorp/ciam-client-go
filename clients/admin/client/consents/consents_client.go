// Code generated by go-swagger; DO NOT EDIT.

package consents

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new consents API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new consents API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new consents API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for consents API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateConsent(params *CreateConsentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateConsentCreated, error)

	CreateConsentAction(params *CreateConsentActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateConsentActionCreated, error)

	DeleteConsent(params *DeleteConsentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteConsentNoContent, error)

	DeleteConsentAction(params *DeleteConsentActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteConsentActionNoContent, error)

	GetConsent(params *GetConsentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConsentOK, error)

	GetConsentAction(params *GetConsentActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConsentActionOK, error)

	ListConsentActions(params *ListConsentActionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListConsentActionsOK, error)

	ListConsents(params *ListConsentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListConsentsOK, error)

	ListPrivacyLedgerEventsBySubject(params *ListPrivacyLedgerEventsBySubjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListPrivacyLedgerEventsBySubjectOK, error)

	UpdateConsent(params *UpdateConsentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateConsentCreated, error)

	UpdateConsentAction(params *UpdateConsentActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateConsentActionCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	CreateConsent creates consent

	Consents are created per tenant.

ID, Name and UpdateExistingGrants strategy are required fields when creating a new consent.

UpdateExistingGrants has the following options:

explicitAll - all the existing grants should not be updated. It is required that the user grants the consent explicitly.

implicitAll - all previously existing consent grants should be updated, to the new version of the consent, but

all of those grants should be implicit from the moment on.

keepCurrent - if a previously existing consent grant was set implicitly, it is automatically updated and a new

consent grant is produced, which is also implicit. if a previously existing consent grant was set
explicitly, it should not be updated. It is required that the user grants the consent explicitly.
*/
func (a *Client) CreateConsent(params *CreateConsentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateConsentCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateConsentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createConsent",
		Method:             "POST",
		PathPattern:        "/consents",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateConsentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateConsentCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createConsent: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	CreateConsentAction creates consent action

	Consent action allows to group list of consents. A Tenant Application asking for the consent it can

ask for +by the action name+ instead of asking for a list of consents directly. It allows for cleaner
abstraction and adds the ability to dynamically configure the consents required for particular applications.

ID and Name are required fields.

For each consent provide id and specify if it is required.
*/
func (a *Client) CreateConsentAction(params *CreateConsentActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateConsentActionCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateConsentActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createConsentAction",
		Method:             "POST",
		PathPattern:        "/actions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateConsentActionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateConsentActionCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createConsentAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteConsent deletes consent

Delete consent.
*/
func (a *Client) DeleteConsent(params *DeleteConsentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteConsentNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConsentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteConsent",
		Method:             "DELETE",
		PathPattern:        "/consents/{consent}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConsentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteConsentNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteConsent: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteConsentAction deletes consent action

Delete consent action.
*/
func (a *Client) DeleteConsentAction(params *DeleteConsentActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteConsentActionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConsentActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteConsentAction",
		Method:             "DELETE",
		PathPattern:        "/actions/{action}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConsentActionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteConsentActionNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteConsentAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetConsent gets consent details

Get consent details.
*/
func (a *Client) GetConsent(params *GetConsentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConsentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConsentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getConsent",
		Method:             "GET",
		PathPattern:        "/consents/{consent}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConsentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetConsentOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getConsent: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetConsentAction gets consent action with consents

Get consent action with consents.
*/
func (a *Client) GetConsentAction(params *GetConsentActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConsentActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConsentActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getConsentAction",
		Method:             "GET",
		PathPattern:        "/actions/{action}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConsentActionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetConsentActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getConsentAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListConsentActions lists consent actions

List consent actions.
*/
func (a *Client) ListConsentActions(params *ListConsentActionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListConsentActionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListConsentActionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listConsentActions",
		Method:             "GET",
		PathPattern:        "/actions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListConsentActionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListConsentActionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listConsentActions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListConsents lists consents

List consents.
*/
func (a *Client) ListConsents(params *ListConsentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListConsentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListConsentsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listConsents",
		Method:             "GET",
		PathPattern:        "/consents",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListConsentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListConsentsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listConsents: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListPrivacyLedgerEventsBySubject lists privacy ledger events

List privacy ledger events.
*/
func (a *Client) ListPrivacyLedgerEventsBySubject(params *ListPrivacyLedgerEventsBySubjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListPrivacyLedgerEventsBySubjectOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListPrivacyLedgerEventsBySubjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listPrivacyLedgerEventsBySubject",
		Method:             "GET",
		PathPattern:        "/events",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListPrivacyLedgerEventsBySubjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListPrivacyLedgerEventsBySubjectOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listPrivacyLedgerEventsBySubject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	UpdateConsent updates consent

	Every time consent is updated, its version is incremented.

If ValidFrom attribute is not provided it will be set to current time.
*/
func (a *Client) UpdateConsent(params *UpdateConsentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateConsentCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateConsentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateConsent",
		Method:             "PUT",
		PathPattern:        "/consents/{consent}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateConsentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateConsentCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateConsent: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateConsentAction updates consent action

Update consent action.
*/
func (a *Client) UpdateConsentAction(params *UpdateConsentActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateConsentActionCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateConsentActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateConsentAction",
		Method:             "PUT",
		PathPattern:        "/actions/{action}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateConsentActionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateConsentActionCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateConsentAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
