// Code generated by go-swagger; DO NOT EDIT.

package users

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new users API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for users API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	ActivateSelfRegisteredUser(params *ActivateSelfRegisteredUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActivateSelfRegisteredUserCreated, error)

	ActivateSelfRegisteredUserUsingExtendedCode(params *ActivateSelfRegisteredUserUsingExtendedCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActivateSelfRegisteredUserUsingExtendedCodeCreated, error)

	BeginWebAuthnCredentialsGeneration(params *BeginWebAuthnCredentialsGenerationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BeginWebAuthnCredentialsGenerationOK, error)

	ChangePassword(params *ChangePasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChangePasswordNoContent, error)

	ChangeTotpSecret(params *ChangeTotpSecretParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChangeTotpSecretNoContent, error)

	CompleteResetPassword(params *CompleteResetPasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CompleteResetPasswordNoContent, error)

	CompleteResetTotp(params *CompleteResetTotpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CompleteResetTotpNoContent, error)

	CompleteWebAuthnCredentialsGeneration(params *CompleteWebAuthnCredentialsGenerationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CompleteWebAuthnCredentialsGenerationOK, error)

	ConfirmResetPassword(params *ConfirmResetPasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ConfirmResetPasswordNoContent, error)

	DeleteWebAuthnKey(params *DeleteWebAuthnKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteWebAuthnKeyNoContent, error)

	GenerateActivationCode(params *GenerateActivationCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateActivationCodeCreated, error)

	GenerateCode(params *GenerateCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateCodeCreated, error)

	GenerateCodeForUser(params *GenerateCodeForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateCodeForUserCreated, error)

	NameWebAuthnKey(params *NameWebAuthnKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameWebAuthnKeyNoContent, error)

	RequestResetPassword(params *RequestResetPasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RequestResetPasswordNoContent, error)

	RequestResetTotp(params *RequestResetTotpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RequestResetTotpNoContent, error)

	SelfRegisterUser(params *SelfRegisterUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SelfRegisterUserCreated, error)

	SelfSendActivationMessage(params *SelfSendActivationMessageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SelfSendActivationMessageNoContent, error)

	SetPasswordState(params *SetPasswordStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetPasswordStateNoContent, error)

	SystemAddIdentifier(params *SystemAddIdentifierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemAddIdentifierOK, error)

	SystemAddVerifiableAddress(params *SystemAddVerifiableAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemAddVerifiableAddressOK, error)

	SystemCreateUser(params *SystemCreateUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemCreateUserCreated, error)

	SystemDeleteIdentifier(params *SystemDeleteIdentifierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemDeleteIdentifierNoContent, error)

	SystemDeleteUser(params *SystemDeleteUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemDeleteUserNoContent, error)

	SystemDeleteVerifiableAddress(params *SystemDeleteVerifiableAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemDeleteVerifiableAddressNoContent, error)

	SystemGetUser(params *SystemGetUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemGetUserOK, error)

	SystemGetUserByKey(params *SystemGetUserByKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemGetUserByKeyOK, error)

	SystemListUsers(params *SystemListUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemListUsersOK, error)

	SystemUpdateUser(params *SystemUpdateUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemUpdateUserOK, error)

	SystemUpdateVerifiableAddress(params *SystemUpdateVerifiableAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemUpdateVerifiableAddressOK, error)

	VerifyPassword(params *VerifyPasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VerifyPasswordOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	ActivateSelfRegisteredUser activates user with code

	Activates (changes status to Active) user if provided code is valid.

Password is optional.
Marks address as verified if not already this user's verified address.
Adds address as identifier if not already this user's identifier.
Invalidates used OTP for account activation.
Fails if address where OTP was sent still belongs to this user.
Fails if user status is not New.
Fails if user has password set and password was provided.
Returns an extended view on user entry (see Get User endpoint).
Endpoint is protected by Brute Force mechanism.
*/
func (a *Client) ActivateSelfRegisteredUser(params *ActivateSelfRegisteredUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActivateSelfRegisteredUserCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActivateSelfRegisteredUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "activateSelfRegisteredUser",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/activate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActivateSelfRegisteredUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActivateSelfRegisteredUserCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for activateSelfRegisteredUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	ActivateSelfRegisteredUserUsingExtendedCode activates user using extended code

	Activates (changes status to Active) user using extended OTP if the provided code is valid.

Password is optional.
Marks address as verified if it's not yet a verified address of this user.
Adds address as identifier if it's not yet an identifier of this user.
Invalidates used OTP for account activation.
Fails if address where OTP was sent still belongs to this user.
Fails if user status is not New.
Fails if user has password set already and password was provided.
Returns an extended view on user entry (see Get User endpoint).
Endpoint is protected by Brute Force mechanism.
*/
func (a *Client) ActivateSelfRegisteredUserUsingExtendedCode(params *ActivateSelfRegisteredUserUsingExtendedCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActivateSelfRegisteredUserUsingExtendedCodeCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActivateSelfRegisteredUserUsingExtendedCodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "activateSelfRegisteredUserUsingExtendedCode",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/user/activate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActivateSelfRegisteredUserUsingExtendedCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActivateSelfRegisteredUserUsingExtendedCodeCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for activateSelfRegisteredUserUsingExtendedCode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BeginWebAuthnCredentialsGeneration begins web authn credentials generation

Begin WebAuthn credentials generation
*/
func (a *Client) BeginWebAuthnCredentialsGeneration(params *BeginWebAuthnCredentialsGenerationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BeginWebAuthnCredentialsGenerationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBeginWebAuthnCredentialsGenerationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "beginWebAuthnCredentialsGeneration",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/webauthn/create/begin",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BeginWebAuthnCredentialsGenerationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BeginWebAuthnCredentialsGenerationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for beginWebAuthnCredentialsGeneration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	ChangePassword changes password

	Changes user password if the provided password matches the current user password.

Fails if the current password is not set. For setting a password for user use the reset password flow.
Endpoint is protected by Brute Force mechanism.
*/
func (a *Client) ChangePassword(params *ChangePasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChangePasswordNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewChangePasswordParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "changePassword",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/change_password",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ChangePasswordReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ChangePasswordNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for changePassword: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	ChangeTotpSecret changes totp secret

	Changes user totp secret if the provided totp code matches is valid.

Fails if totp secret is not set. For setting a totp secret for user use the reset totp secret flow.
Endpoint is protected by Brute Force mechanism.
*/
func (a *Client) ChangeTotpSecret(params *ChangeTotpSecretParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChangeTotpSecretNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewChangeTotpSecretParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "changeTotpSecret",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/totp/change",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ChangeTotpSecretReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ChangeTotpSecretNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for changeTotpSecret: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	CompleteResetPassword completes reset password

	Resets password for user if the provided OTP is valid. It's the second and final step of the

flow to reset the password.
Either address (must be a valid email or mobile which is marked as verified address for the user), user id, identifier (must be user's identifier) or extended code must be provided.
Endpoint returns generic `401` regardless of the reason of failure to prevent email/mobile enumeration.
After a successful password reset, OTP gets invalidated, so it cannot be reused.
Endpoint is protected by Brute Force mechanism.
*/
func (a *Client) CompleteResetPassword(params *CompleteResetPasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CompleteResetPasswordNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCompleteResetPasswordParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "completeResetPassword",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/user/password/reset/complete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CompleteResetPasswordReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CompleteResetPasswordNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for completeResetPassword: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	CompleteResetTotp completes reset totp secret

	Resets totp secret for user if the provided OTP is valid. It's the second and final step of the

flow to reset totp secret.
Either address (must be a valid email or mobile which is marked as verified address for the user), user id, identifier (must be user's identifier) or extended code must be provided.
Endpoint returns generic `401` regardless of the reason of failure to prevent email/mobile enumeration.
After a successful totp secret reset, OTP gets invalidated, so it cannot be reused.
Endpoint is protected by Brute Force mechanism.
*/
func (a *Client) CompleteResetTotp(params *CompleteResetTotpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CompleteResetTotpNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCompleteResetTotpParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "completeResetTotp",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/user/totp/reset/complete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CompleteResetTotpReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CompleteResetTotpNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for completeResetTotp: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CompleteWebAuthnCredentialsGeneration finishes web authn credentials generation

Finish WebAuthn credentials generation
*/
func (a *Client) CompleteWebAuthnCredentialsGeneration(params *CompleteWebAuthnCredentialsGenerationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CompleteWebAuthnCredentialsGenerationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCompleteWebAuthnCredentialsGenerationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "completeWebAuthnCredentialsGeneration",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/webauthn/create/complete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CompleteWebAuthnCredentialsGenerationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CompleteWebAuthnCredentialsGenerationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for completeWebAuthnCredentialsGeneration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	ConfirmResetPassword confirms reset password

	Resets password for user if the provided OTP is valid. It's the second and final step of the

flow to reset the password.
Either identifier (must be a valid email or mobile which is marked as verified address for the user), user id or extended code must be provided.
Endpoint returns generic `401` regardless of the reason of failure to prevent email/mobile enumeration.
After a successful password reset, OTP gets invalidated, so it cannot be reused.
Endpoint is protected by Brute Force mechanism.
*/
func (a *Client) ConfirmResetPassword(params *ConfirmResetPasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ConfirmResetPasswordNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewConfirmResetPasswordParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "confirmResetPassword",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/user/password/reset/confirm",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ConfirmResetPasswordReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ConfirmResetPasswordNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for confirmResetPassword: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteWebAuthnKey deletes web authn key

Deletes WebAuthn key.
*/
func (a *Client) DeleteWebAuthnKey(params *DeleteWebAuthnKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteWebAuthnKeyNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteWebAuthnKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteWebAuthnKey",
		Method:             "DELETE",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/webauthn/{webAuthnCredentialID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteWebAuthnKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteWebAuthnKeyNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteWebAuthnKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	GenerateActivationCode generates activation code

	Generate an activation code for provided address

Invalidates previously generated OTPs for user activation.
Activation code is valid for specific period of time configured in Identity Pool.

NOTE: this API is deprecated, please use the one for generating code of a specific type with type `activation`
REFACTORED: input field name has been changed from `identifier` to `address`; field `identifier` stays for backward compatibility and overrides `address` if not empty
*/
func (a *Client) GenerateActivationCode(params *GenerateActivationCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateActivationCodeCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenerateActivationCodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generateActivationCode",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/activation/generate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenerateActivationCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenerateActivationCodeCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generateActivationCode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	GenerateCode generates code of a specific type

	Generate code of a specific type

Invalidates previously generated OTPs for action associated with the type.
Code is valid for specific period of time configured in Identity Pool.

Keep in mind that `address` attribute for different code types may be optional and may not mean the same:
for `reset_password`, `authentication` and `challenge` it is optional, but if provided must be user's address (verified or unverified)
for `activation` it is not mandatory (system will pick up address itself if there is only one in user entry) but if provided it must be one of the user's addresses (can be not verified)
for `verify_address` it must be user's unverified address and that address cannot be someone's else verified address

For `activation`, `reset_password` and `challenge` there is only one active code for a user (generating new one invalidates previous)
For `verify_address` there might be many codes for a user. During verification latest for an address is being compared.
*/
func (a *Client) GenerateCode(params *GenerateCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateCodeCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenerateCodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generateCode",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/code/generate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenerateCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenerateCodeCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generateCode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	GenerateCodeForUser generates code of a specific type

	Generate code of a specific type

Invalidates previously generated OTPs for action associated with the type.
Code is valid for specific period of time configured in Identity Pool.

Either userID or identifier (must be user's identifier) must be provided for most types.
Exceptions are: reset password and challenge if address is user's verified address

Keep in mind that `address` attribute for different code types may be optional and may not mean the same:
for `reset_password`, `authentication` and `challenge` it is not mandatory, but if provided must be user's address (verified or unverified)
for `activation` it is not mandatory (system will pick up address itself if there is only one in user entry) but if provided it must be one of the user's addresses (can be not verified)
for `verify_address` it must be user's unverified address and that address cannot be someone's else verified address

For `activation`, `reset_password` and `challenge` there is only one active code for a user (generating new one invalidates previous)
For `verify_address` there might be many codes for a user. During verification latest for an address is being compared.
*/
func (a *Client) GenerateCodeForUser(params *GenerateCodeForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateCodeForUserCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenerateCodeForUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generateCodeForUser",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/user/code/generate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenerateCodeForUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenerateCodeForUserCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generateCodeForUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
NameWebAuthnKey names web authn key

Set name for WebAuthn key
*/
func (a *Client) NameWebAuthnKey(params *NameWebAuthnKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameWebAuthnKeyNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNameWebAuthnKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nameWebAuthnKey",
		Method:             "PUT",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/webauthn/{webAuthnCredentialID}/name",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NameWebAuthnKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NameWebAuthnKeyNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nameWebAuthnKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	RequestResetPassword requests reset password

	Sends OTP for password reset. It's first out of two steps of the reset password flow.

Address must be a valid email or mobile which is marked as verified address for the user.
For validating unverified address userID or identifier must be provided.
If userID is provided then identifier must not be set.
When both userID or identifier and address are provided then address is taken from user pointed by either userID or identifier.
Regardless if the address points to some user or not, the request ends successfully to
prevent email/mobile enumeration.
Invalidates previously generated OTPs for password reset.
Reset password OTP is valid for a specific period of time configured in Identity Pool.

REFACTORED: input field name has been renamed from `identifier` to `address`; new field `identifier` has been added and described in documentation
*/
func (a *Client) RequestResetPassword(params *RequestResetPasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RequestResetPasswordNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRequestResetPasswordParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "requestResetPassword",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/user/password/reset/request",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RequestResetPasswordReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RequestResetPasswordNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for requestResetPassword: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	RequestResetTotp requests reset totp secret

	Sends OTP for totp secret reset. It's first out of two steps of the reset totp secret flow.

Address must be a valid email or mobile which is marked as verified address for the user.
For validating unverified address userID or identifier must be provided.
If userID is provided then identifier must not be set.
When both userID or identifier and address are provided then address is taken from user pointed by either userID or identifier.
Regardless if the address points to some user or not, the request ends successfully to
prevent email/mobile enumeration.
Invalidates previously generated OTPs for totp reset.
Reset totp secret OTP is valid for a specific period of time configured in Identity Pool.
*/
func (a *Client) RequestResetTotp(params *RequestResetTotpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RequestResetTotpNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRequestResetTotpParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "requestResetTotp",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/user/totp/reset/request",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RequestResetTotpReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RequestResetTotpNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for requestResetTotp: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SelfRegisterUser selves register user

	Creates user using a very basic set of data provided by the user.

Payload and password are optional.
Sets payload and metadata schemas to ones from Identity Pool.
Sets user status to New
If payload is provided it must be valid against payload schema.
Request fails if self registration for Identity Pool is not allowed.
If identifier is someone's verified address or identifier endpoint returns that user ID and end successfully
to prevent email/mobile enumeration. In the same time user whose email/mobile was provided will get notification that
identifier is already used.
If `send_activation_message` query parameter was set to `true`, activation message is sent to provided identifier.
If `code_type_in_message` query parameter was set to link or not provided, link is generated for activation.
Activation message is valid for specific period of time configured in Identity Pool.
If the request succeeds, a new user ID is returned.
Endpoint is protected by Brute Force mechanism.
*/
func (a *Client) SelfRegisterUser(params *SelfRegisterUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SelfRegisterUserCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSelfRegisterUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "selfRegisterUser",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/user/register",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SelfRegisterUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SelfRegisterUserCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for selfRegisterUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SelfSendActivationMessage sends activation message

	Send an activation message to the user's provided address.

When no `address` is provided in the request body, the message is sent to the address saved for this user (if there
is only one address). To prevent email or mobile enumeration, this endpoint does not fail.

The message is **not** sent upon the following:

• `address` is not provided and user has no addresses or more than one.

• `address` is someone else's verified address or identifier. This results in the `Identifier is already used` response.

• The user's `status` is not `new`.

This request invalidates any previously generated OTPs for user account activation.

When `code_type_in_message=link` or no value is provided for it, an activation link is generated.

Activation message validity period is configured in the identity pool settings.

❕ REFACTORED: `identifier` is renamed to `address` in the request body. For backward compatibility, the both
fields are available. If `identifier` is not empty, it overrides the `address` value.
*/
func (a *Client) SelfSendActivationMessage(params *SelfSendActivationMessageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SelfSendActivationMessageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSelfSendActivationMessageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "selfSendActivationMessage",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/activation/send",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SelfSendActivationMessageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SelfSendActivationMessageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for selfSendActivationMessage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SetPasswordState sets password state

	There is a set of well-defined states password can be in:

`valid` - password is valid and can be used for authentication etc.
`must_be_reset` - password is not valid for authentication and must be reset
`must_be_changed` - password is valid for one authentication and then must be changed or will be moved to `must_be_reset` state
*/
func (a *Client) SetPasswordState(params *SetPasswordStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetPasswordStateNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetPasswordStateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "setPasswordState",
		Method:             "PUT",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/password/state",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetPasswordStateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SetPasswordStateNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for setPasswordState: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SystemAddIdentifier adds identifier

	Add an identifier to the user account in the specified identity pool.

The identifier must be unique within the user's account.
*/
func (a *Client) SystemAddIdentifier(params *SystemAddIdentifierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemAddIdentifierOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemAddIdentifierParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemAddIdentifier",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/identifiers/add",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemAddIdentifierReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemAddIdentifierOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemAddIdentifier: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SystemAddVerifiableAddress adds verifiable address

Adds a verifiable address to the user account
*/
func (a *Client) SystemAddVerifiableAddress(params *SystemAddVerifiableAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemAddVerifiableAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemAddVerifiableAddressParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemAddVerifiableAddress",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/addresses/add",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemAddVerifiableAddressReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemAddVerifiableAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemAddVerifiableAddress: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SystemCreateUser creates user

	Create a user with extended data.

Any status and set of identifiers, addresses, and credentials are allowed.
If credential of type password is provided it can be marked as must_be_changed which forces user to change its password upon first login.

When no `payload_schema_id` or `metadata_schema_id` are provided, the default values are taken from the
specified Identity Pool.

Payload and metadata must match the specified schema.

The response contains an extended view on user entry.

To retrieve a user entry without user creation, call the **Get User Details** endpoint.
*/
func (a *Client) SystemCreateUser(params *SystemCreateUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemCreateUserCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemCreateUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemCreateUser",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemCreateUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemCreateUserCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemCreateUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SystemDeleteIdentifier removes identifier

Remove an identifier from the specified user account.
*/
func (a *Client) SystemDeleteIdentifier(params *SystemDeleteIdentifierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemDeleteIdentifierNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemDeleteIdentifierParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemDeleteIdentifier",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/identifiers/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemDeleteIdentifierReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemDeleteIdentifierNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemDeleteIdentifier: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SystemDeleteUser deletes user account

Remove a record about a user account in the specified identity pool.
*/
func (a *Client) SystemDeleteUser(params *SystemDeleteUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemDeleteUserNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemDeleteUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemDeleteUser",
		Method:             "DELETE",
		PathPattern:        "/system/pools/{ipID}/users/{userID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemDeleteUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemDeleteUserNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemDeleteUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SystemDeleteVerifiableAddress deletes verifiable address

Remove a verifiable address from a user account so it is no longer associated with the specified user.
*/
func (a *Client) SystemDeleteVerifiableAddress(params *SystemDeleteVerifiableAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemDeleteVerifiableAddressNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemDeleteVerifiableAddressParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemDeleteVerifiableAddress",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/addresses/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemDeleteVerifiableAddressReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemDeleteVerifiableAddressNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemDeleteVerifiableAddress: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SystemGetUser gets user details

	Retrieve extended information about a user record.

The response contains user's basic details, payload, and metadata, as well as all their identifiers,
addresses, and blurred credentials.
*/
func (a *Client) SystemGetUser(params *SystemGetUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemGetUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemGetUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemGetUser",
		Method:             "GET",
		PathPattern:        "/system/pools/{ipID}/users/{userID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemGetUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemGetUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemGetUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SystemGetUserByKey gets user details by key

	Retrieve extended information about a user record found by provided key.

Only one of `identifier` or `address` can be provided.
Address must be user's verified address. It's not possible to find user by unverified address.

The response contains user's basic details, payload, and metadata, as well as all their identifiers,
addresses, and blurred credentials.
*/
func (a *Client) SystemGetUserByKey(params *SystemGetUserByKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemGetUserByKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemGetUserByKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemGetUserByKey",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/by_key",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemGetUserByKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemGetUserByKeyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemGetUserByKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SystemListUsers lists users

	Retrieve the list of users from the specified identity pool.

Results are sorted by user ID. No other sorting is supported.

This API does not use ETags. Data returned in the response is eventually consistent.
It's not possible to enforce full consistency for this API.
*/
func (a *Client) SystemListUsers(params *SystemListUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemListUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemListUsersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemListUsers",
		Method:             "GET",
		PathPattern:        "/system/pools/{ipID}/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemListUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemListUsersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemListUsers: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SystemUpdateUser updates user record

	Update the basic set of user data: payload, metadata, schemas, and status. Provide the required values for the fields

you need to update. Fields (top level elements like `status`, `payload` etc.) with no values are skipped for the update (not removed nor cleared).

The fields to be updated are overridden.

Any `payload` / `metadata` and `payload_schema_id` / `metadata_schema_id` values passed must be mutually relevant.

To retrieve a user entry without updating their record, call the **Get User Details** endpoint.

Please notice that `deleted` status may be used as soft-delete but does not have any special meaning in the
system besides it does not allow such user to authenticate.
*/
func (a *Client) SystemUpdateUser(params *SystemUpdateUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemUpdateUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemUpdateUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemUpdateUser",
		Method:             "PUT",
		PathPattern:        "/system/pools/{ipID}/users/{userID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemUpdateUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemUpdateUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemUpdateUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SystemUpdateVerifiableAddress updates verifiable address

Update a verifiable address for the user account.
*/
func (a *Client) SystemUpdateVerifiableAddress(params *SystemUpdateVerifiableAddressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SystemUpdateVerifiableAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSystemUpdateVerifiableAddressParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "systemUpdateVerifiableAddress",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/users/{userID}/addresses/update",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SystemUpdateVerifiableAddressReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SystemUpdateVerifiableAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for systemUpdateVerifiableAddress: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	VerifyPassword verifies user s password

	Verifies user's password.

Either identifier (must be user's identifier) or user ID must be provided.
Endpoint is protected by Brute Force mechanism.
This endpoint is meant for integration when external system verifies user's password.

REFACTORED: input field name has been changed from `id` to `userID`; field `id` stays for backward compatibility and overrides `userID` if not empty
*/
func (a *Client) VerifyPassword(params *VerifyPasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VerifyPasswordOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVerifyPasswordParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "verifyPassword",
		Method:             "POST",
		PathPattern:        "/system/pools/{ipID}/user/password/verify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VerifyPasswordReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VerifyPasswordOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for verifyPassword: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
